name: Notify Discord on section change
on:
  push:
    branches:
      - '**'

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # potřebujeme historii pro diff

      - name: Detect changes in target file
        id: detect
        env:
          TARGET_FILE: changelog.md  # ← uprav cestu
        run: |
          # Zjistíme poslední commit před HEAD (funguje i pro více commitů v pushi)
          PREV_SHA=$(git rev-parse HEAD~1)

          # Jestli se soubor změnil v diffu (přesně shoda cesty)
          if git diff --name-only "$PREV_SHA" HEAD | grep -x "$TARGET_FILE" >/dev/null; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract changed sections between headings
        id: extract
        if: steps.detect.outputs.changed == 'true'
        env:
          TARGET_FILE: path/to/your-file.md  # ← stejná cesta
        run: |
          PREV_SHA=$(git rev-parse HEAD~1)

          # Vytvoříme unified diff jen pro cílový soubor
          DIFF=$(git diff -U0 "$PREV_SHA" HEAD -- "$TARGET_FILE")

          # Najdeme všechny nadpisy "## ..." jejichž řádky jsou dotčené změnou
          # V diffu `@@ -a,b +c,d @@` jsou bloky a změněné řádky začínají + nebo -.
          # Chceme start sekce = nejbližší nadpis "## " nad změněným řádkem v aktuální verzi souboru.
          # Postup:
          # 1) Najdeme řádky s plus (+) nebo minus (-), uložíme jejich čísla v aktuální verzi (pravé číslo z hlavičky).
          # 2) Pro každý změněný řádek najdeme v aktuálním souboru "nahoru" nejbližší "## " a vezmeme jako začátek sekce.
          # 3) Pak seřezeme od tohoto nadpisu po další "## " (exklusivně).

          # Vytvoříme mapu změněných řádků v CURRENT (po změně)
          # Vytáhneme z hlaviček difu rozsahy +c,d
          awkRanges() {
            awk '
              /^@@/ {
                # Formát hlavičky: @@ -a,b +c,d @@
                match($0, /\+([0-9]+),?([0-9]+)?/)
                start = int(substr($0, RSTART+1, RLENGTH-1))
                # pokud není d, bereme 1
                count = 1
                if (match($0, /\+([0-9]+),([0-9]+)/)) {
                  count = int(substr($0, RSTART + RLENGTH - length($0), RLENGTH)) # fallback, upravíme níže
                }
              }
              /^[+-]/ {
                if (substr($0,1,1) == "+" || substr($0,1,1) == "-") {
                  # přidáme rozsah bloků, reálně nám stačí info, že blok obsahuje změny
                  print start
                }
              }
            '
          }

          # Jednodušší cesta: použijeme grep na aktuálním souboru a pro každou změnu hledáme sekci.
          # 1) Vytvoříme seznam nadpisů s jejich čísly řádků v CURRENT.
          mapfile -t HEADINGS < <(nl -ba "$TARGET_FILE" | grep -nE "^[[:space:]]*##[[:space:]]" || true)

          # 2) Vytvoříme seznam změněných řádků (jen indikace bloků + vezmeme kontext přes hunk hlavičky)
          # Z hlaviček hunků získáme start aktuálního rozsahu +c,d
          mapfile -t HUNK_STARTS < <(echo "$DIFF" | grep -E "^@@" | sed -E 's/.*\+([0-9]+)(,([0-9]+))?.*/\1/' || true)
          mapfile -t HUNK_COUNTS < <(echo "$DIFF" | grep -E "^@@" | sed -E 's/.*\+[0-9]+(,([0-9]+))?.*/\2/' | sed 's/,//' || true)

          # Pokud není count, použijeme 1
          COUNTS=()
          for c in "${HUNK_COUNTS[@]}"; do
            if [[ -z "$c" ]]; then COUNTS+=(1); else COUNTS+=("$c"); fi
          done

          # 3) Pro každý hunk najdeme nadpis "## " těsně před jeho startem
          # HEADINGS položka vypadá jako: "   42\t## Název sekce"
          # line číslo je první sloupec před tabem
          get_section_bounds() {
            local start_line="$1"
            local last_heading_line=0
            local next_heading_line=0

            # Najdi poslední heading s line < start_line
            for h in "${HEADINGS[@]}"; do
              line=$(echo "$h" | awk -F'\t' '{print $1}')
              title=$(echo "$h" | awk -F'\t' '{print $2}')
              # line může obsahovat mezery, ořežeme
              line=$(echo "$line" | tr -d ' ')
              if [[ "$line" -lt "$start_line" ]]; then
                last_heading_line="$line"
              else
                next_heading_line="$line"
                break
              fi
            done

            # Pokud jsme nenašli další heading, vezmeme konec souboru
            if [[ "$next_heading_line" -eq 0 ]]; then
              next_heading_line=$(wc -l < "$TARGET_FILE")
              next_heading_line=$((next_heading_line + 1))
            fi

            echo "$last_heading_line $next_heading_line"
          }

          # 4) Vyextrahujeme unikátní sekce
          SECTIONS=()
          for i in "${!HUNK_STARTS[@]}"; do
            start="${HUNK_STARTS[$i]}"
            read H_START H_END < <(get_section_bounds "$start")

            if [[ "$H_START" -gt 0 && "$H_END" -gt "$H_START" ]]; then
              # Přidej rozsah "H_START:H_END-1" (bez dalšího nadpisu)
              SECTIONS+=("$H_START:$((H_END-1))")
            fi
          done

          # Odstraníme duplikáty
          uniq_sections=()
          for s in "${SECTIONS[@]}"; do
            [[ " ${uniq_sections[*]} " == *" $s "* ]] || uniq_sections+=("$s")
          done

          # 5) Poskládáme obsah
          OUTPUT_FILE="__changed_sections.txt"
          : > "$OUTPUT_FILE"
          for range in "${uniq_sections[@]}"; do
            start=${range%%:*}
            end=${range##*:}
            # Vytáhneme obsah mezi start a end
            sed -n "${start},${end}p" "$TARGET_FILE" >> "$OUTPUT_FILE"
            echo -e "\n" >> "$OUTPUT_FILE"
          done

          # Pokud není co poslat, nastav flag
          if [[ ! -s "$OUTPUT_FILE" ]]; then
            echo "has_sections=false" >> $GITHUB_OUTPUT
          else
            echo "has_sections=true" >> $GITHUB_OUTPUT
            # Uložíme obsah jako výstup (ořízneme na ~1800 znaků kvůli Discord limitům embedu)
            CONTENT=$(head -c 1800 "$OUTPUT_FILE" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
            echo "content=$CONTENT" >> $GITHUB_OUTPUT
          fi

      - name: Send message to Discord
        if: steps.extract.outputs.has_sections == 'true'
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          # Pošleme jako čistý text (content). Pokud chceš embed, můžeme upravit.
          JSON_PAYLOAD="{\"content\":\"$CONTENT\"}"
          curl -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK_URL"
        shell: bash
